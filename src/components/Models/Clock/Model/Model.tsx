/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 --types ./public/clock.glb --transform -s
*/

import { animated, useSpring } from "@react-spring/three";
import { useGLTF, useProgress } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useEffect, useRef, useTransition } from "react";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
import { useSetupMaterial } from "./useSetupMaterial";

type GLTFResult = GLTF & {
  nodes: {
    clockShellMesh: THREE.Mesh;
    clockShellMesh_1: THREE.Mesh;
    glass: THREE.Mesh;
    minutesMarker: THREE.Mesh;
    clockText: THREE.Mesh;
    handHour: THREE.Mesh;
    handMinute: THREE.Mesh;
    handSecond: THREE.Mesh;
    handPin: THREE.Mesh;
  };
  materials: {
    clockShellFaceMaterial: THREE.MeshStandardMaterial;
    ClockShellMaterial: THREE.MeshStandardMaterial;
  };
};

interface ModelProps {
  hours: number;
  minutes: number;
  seconds: number;
}

function Model({ hours, minutes, seconds }: ModelProps) {
  const { nodes } = useGLTF("/clock-transformed.glb") as GLTFResult;
  const {
    showGlass,
    glassMaterial,
    clockShellMaterial,
    clockHandMaterial,
    clockFaceMaterial,
    clockTextMaterial,
  } = useSetupMaterial();

  const [, startTransition] = useTransition();

  const secondHandRef = useRef<THREE.Mesh>(null);
  const minuteHandRef = useRef<THREE.Mesh>(null);
  const hourHandRef = useRef<THREE.Mesh>(null);

  useFrame(() => {
    startTransition(() => {
      if (
        secondHandRef.current &&
        minuteHandRef.current &&
        hourHandRef.current
      ) {
        secondHandRef.current.rotation.z = -THREE.MathUtils.degToRad(
          seconds * 6
        );
        minuteHandRef.current.rotation.z = -THREE.MathUtils.degToRad(
          minutes * 6
        );
        hourHandRef.current.rotation.z = -THREE.MathUtils.degToRad(hours * 30);
      }
    });
  });

  const groupRef = useRef<THREE.Group>(null);

  const { progress } = useProgress();

  const [springs, api] = useSpring(() => ({
    scale: 0,
    rotation: 0,
    config: {
      mass: 4,
      friction: 30,
    },
  }));

  useEffect(() => {
    startTransition(() => {
      if (progress === 100) {
        api.start({
          scale: 1.2,
        });
      }
    });
  }, [api, progress]);

  // useFrame(({ clock }) => {
  //   startTransition(() => {
  //     if (groupRef.current)
  //       groupRef.current.rotation.y =
  //         Math.sin(clock.getElapsedTime() / 2) + Math.PI / 6;
  //   });
  // });

  return (
    <>
      <animated.group dispose={null} ref={groupRef} scale={springs.scale}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.glass.geometry}
          material={glassMaterial}
          visible={showGlass}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.minutesMarker.geometry}
          material={nodes.minutesMarker.material}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.clockText.geometry}
          material={clockTextMaterial}
        />
        <mesh
          ref={hourHandRef}
          castShadow
          receiveShadow
          geometry={nodes.handHour.geometry}
          material={clockHandMaterial}
        />
        <mesh
          ref={minuteHandRef}
          castShadow
          receiveShadow
          geometry={nodes.handMinute.geometry}
          material={clockHandMaterial}
        />
        <mesh
          ref={secondHandRef}
          castShadow
          receiveShadow
          geometry={nodes.handSecond.geometry}
          material={clockHandMaterial}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.handPin.geometry}
          material={clockHandMaterial}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.clockShellMesh.geometry}
          material={clockFaceMaterial}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.clockShellMesh_1.geometry}
          material={clockShellMaterial}
        />
      </animated.group>
    </>
  );
}

useGLTF.preload("/clock-transformed.glb");

export default Model;
